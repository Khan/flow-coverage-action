{"version":3,"sources":["flow-coverage-linter.js","flow-coverage.js"],"names":["require","execSync","path","fs","flowUncoveredLineRegex","flowNextUncoveredLineRegex","findIgnoredLinesAndPositions","text","lines","split","ignored","lineOffsets","ignoreBlocks","unmatchedBlocks","ignoring","next","numLines","blockStart","forEach","line","i","length","match","push","Error","test","ignoredLines","ignoredBlocks","collectWarnings","fileName","lineStats","uncoveredLocs","alreadyWarned","errorExists","warnings","blockEnd","start","column","end","annotationLevel","message","offset","isOneLine","passable","currentBlock","shift","blockLength","Math","floor","threshold","getCoverage","flowBin","filePath","stdout","resolve","toString","data","JSON","parse","isUncoveredFile","sourceText","includes","checkFile","readFileSync","expressions","uncovered_count","ignoredLinesAndPositions","uncovered_locs","err","module","exports","sendReport","run","filesList","jsFiles","filter","file","endsWith","console","log","allAnnotations","annotations","process","argv","_","__","argvFiles","catch","error","exit","env","filesRaw"],"mappings":"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","file":"flow-coverage.js","sourceRoot":"..","sourcesContent":["// @flow\n\nconst {execSync} = require('child_process');\nconst path = require('path');\n\nconst fs = require('fs');\n\n// Allows text after comment explaining why\nconst flowUncoveredLineRegex = /(\\/\\/\\s*flow-uncovered-line[\\s:]?.*|\\/\\*\\s*flow-uncovered-line(\\s+[^*]*)?\\*\\/)/;\nconst flowNextUncoveredLineRegex = /(\\/\\/\\s*flow-(next-uncovered|uncovered-next)-line|\\/\\*\\s*flow-(next-uncovered|uncovered-next)-line(\\s+[^*]*)?\\*\\/)/;\n\nconst findIgnoredLinesAndPositions = (path, text) => {\n    const lines = text.split('\\n');\n    const ignored /*: {[key: number]: boolean} */ = {};\n    const lineOffsets /*: {[key: number]: number} */ = {};\n    const ignoreBlocks = [];\n    const unmatchedBlocks = [];\n    let ignoring = false;\n    let next = false;\n    let numLines = 0;\n    let blockStart = 0;\n    lineOffsets[0] = 0;\n\n    lines.forEach((line, i) => {\n        i = i + 1; // one-indexed\n        lineOffsets[i] = lineOffsets[i - 1] + line.length + 1;\n        if (line.match(/^\\s*\\/\\* flow-uncovered-block \\*\\//)) {\n            if (ignoring) {\n                unmatchedBlocks.push([blockStart, i - 1]);\n            }\n            ignoring = true;\n            blockStart = i;\n            return;\n        } else if (line.match(/^\\s*\\/\\* end flow-uncovered-block \\*\\//)) {\n            if (!ignoring) {\n                throw new Error('unmatched end ignore pragma');\n            }\n            ignoring = false;\n            ignoreBlocks.push([blockStart, i]);\n            return;\n        }\n        if (next || flowUncoveredLineRegex.test(line)) {\n            next = false;\n            ignored[i] = true;\n        } else if (ignoring) {\n            ignored[i] = true;\n        }\n        next = flowNextUncoveredLineRegex.test(line);\n        numLines = i;\n    });\n    return {\n        unmatchedBlocks: unmatchedBlocks,\n        ignoredLines: ignored,\n        ignoredBlocks: ignoreBlocks,\n        numLines: numLines,\n        lineOffsets: lineOffsets,\n    };\n};\n\nconst collectWarnings = (fileName, lineStats, uncoveredLocs) => {\n    const alreadyWarned /*: {[key: number]: boolean} */ = {};\n    const errorExists /*: {[key: number]: boolean} */ = {};\n    const warnings /*: Array<{\n        path: string,\n        start: {line: number, column: number},\n        end: {line: number, column: number},\n        annotationLevel: 'warning' | 'failure',\n        message: string,\n        offset: number,\n    }> */ = [];\n    const {\n        ignoredLines,\n        ignoredBlocks,\n        numLines,\n        lineOffsets,\n        unmatchedBlocks,\n    } = lineStats;\n    const threshold = 0.8;\n\n    unmatchedBlocks.forEach(([blockStart, blockEnd]) => {\n        warnings.push({\n            path: fileName,\n            start: {line: blockStart, column: 0},\n            end: {line: blockEnd, column: 0},\n            annotationLevel: 'failure',\n            message: `Unmatched /* flow-uncovered-block */`,\n            offset: lineOffsets[blockStart],\n        });\n    });\n\n    uncoveredLocs.forEach(({start, end}) => {\n        if (alreadyWarned[start.line]) {\n            return;\n        }\n        const isOneLine = start.line === end.line;\n        errorExists[start.line] = true;\n        if (isOneLine) {\n            if (!ignoredLines[start.line]) {\n                alreadyWarned[start.line] = true;\n                warnings.push({\n                    path: fileName,\n                    start,\n                    end,\n                    annotationLevel: 'failure',\n                    message: `The expression from ${start.line}:${\n                        start.column\n                    }-${\n                        end.column\n                        // Note that the `${''}` trick is so that it won't trip the regex that's looking for these comments\n                    } is not covered by flow! If it's unavoidable, put '// flow-${''}uncovered-line' at the end of the line`,\n                    offset: start.offset,\n                });\n            }\n        } else {\n            let ignored = true;\n            for (let i = start.line; i <= end.line; i++) {\n                if (!ignoredLines[i]) {\n                    ignored = false;\n                }\n                errorExists[i] = true;\n            }\n            if (!ignored) {\n                alreadyWarned[start.line] = true;\n                warnings.push({\n                    path: fileName,\n                    start,\n                    end,\n                    annotationLevel: 'failure',\n                    message: `The expression from ${start.line}:${start.column}-${end.line}:${end.column} is not covered by flow! If it's unavoidable, surround the expression in '/* flow-uncovered-block */' and '/* end flow-uncovered-block */'`,\n                    offset: start.offset,\n                });\n            }\n        }\n    });\n    let passable = 0;\n    let currentBlock /*: ?[number, number] */ = ignoredBlocks.shift();\n    for (let line = 1; line <= numLines; line++) {\n        if (ignoredLines[line] && !errorExists[line]) {\n            if (\n                currentBlock &&\n                currentBlock[0] <= line &&\n                line <= currentBlock[1]\n            ) {\n                passable += 1;\n            } else {\n                const offset = lineOffsets[line] - 1;\n                warnings.push({\n                    path: fileName,\n                    start: {line, column: 0},\n                    end: {line, column: 0},\n                    annotationLevel: 'failure',\n                    message: `The expression in line ${line} is covered by flow! You should remove any '// flow-${''}uncovered-line' or '/* flow-uncovered-block */' comments applying to this line.`,\n                    offset: offset,\n                });\n            }\n        }\n        if (currentBlock && line === currentBlock[1]) {\n            const blockLength = currentBlock[1] - currentBlock[0];\n            const offset = lineOffsets[currentBlock[0]] - 1;\n            if (blockLength > 0 && passable / blockLength > threshold) {\n                warnings.push({\n                    path: fileName,\n                    start: {line: currentBlock[0], column: 0},\n                    end: {line: currentBlock[1], column: 0},\n                    annotationLevel: 'failure',\n                    message: `More than ${Math.floor(\n                        threshold * 100,\n                    )}% of lines in the 'flow-uncovered-block' from lines ${\n                        currentBlock[0]\n                    }-${\n                        currentBlock[1]\n                    } are covered by flow! You should remove this comment from the entire block and instead cover individual lines using '// flow-${''}uncovered-line'.`,\n                    offset: offset,\n                });\n            }\n            passable = 0;\n            currentBlock = ignoredBlocks.shift();\n        }\n    }\n\n    return warnings;\n};\n\n/*::\ntype CoverageInfo = {|\n        expressions: {|\n            uncovered_count: number,\n            covered_count: number,\n            uncovered_locs: $ReadOnlyArray<{|\n                start: {line: number, column: number, offset: number},\n                end: {line: number, column: number, offset: number},\n            |}>,\n        |},\n    |}\n*/\n\nconst getCoverage = (flowBin, filePath) => {\n    const stdout = execSync(\n        path.resolve(flowBin) + ` coverage --json ${filePath}`,\n    ).toString('utf8');\n    const data /*: CoverageInfo */ = JSON.parse(stdout); // flow-uncovered-line\n\n    return data;\n};\n\nconst isUncoveredFile = (sourceText) =>\n    sourceText.split('\\n').includes('/* flow-uncovered-file */');\n\nconst checkFile = (flowBin /*: string */, filePath /*: string */) => {\n    const sourceText = fs.readFileSync(filePath).toString('utf8');\n\n    if (isUncoveredFile(sourceText)) {\n        // Skipping this one\n        return [];\n    }\n\n    // not flow checked\n    if (!sourceText.includes('@flow')) {\n        return [];\n    }\n\n    try {\n        const data = getCoverage(flowBin, filePath);\n        if (!data.expressions.uncovered_count) {\n            // All clear!\n            return [];\n        }\n\n        const ignoredLinesAndPositions = findIgnoredLinesAndPositions(\n            filePath,\n            sourceText,\n        );\n        return collectWarnings(\n            filePath,\n            ignoredLinesAndPositions,\n            data.expressions.uncovered_locs,\n        );\n    } catch (err) {\n        return [\n            {\n                path: filePath,\n                start: {line: 0, column: 0},\n                end: {line: 0, column: 0},\n                annotationLevel: 'failure',\n                message: `Unable to run flow coverage: ` + err.message,\n                offset: 0,\n            },\n        ];\n    }\n};\n\nmodule.exports = checkFile;\n","// @flow\n\n/**\n * This action runs `flow` and lints against uncovered expressions.\n *\n * It uses `send-report.js` to support both running locally (reporting to\n * stdout) and under Github Actions (adding annotations to files in the GitHub\n * UI).\n */\n\n// $FlowFixMe: shhhhh\nrequire('@babel/register');\n\nconst checkFile = require('./flow-coverage-linter');\n\nconst sendReport = require('actions-utils/send-report');\n// const getBaseRef = require('./get-base-ref');\n// const gitChangedFiles = require('./git-changed-files');\n\nasync function run(flowBin, filesList) {\n    const jsFiles = filesList.filter((file) => file.endsWith('.js'));\n    if (!jsFiles.length) {\n        console.log('No files given');\n        return;\n    }\n    const allAnnotations = [];\n    for (const file of jsFiles) {\n        const annotations = await checkFile(flowBin, file);\n        allAnnotations.push(...annotations);\n    }\n    await sendReport('Flow-coverage', allAnnotations);\n}\n\nconst [_, __, flowBin, ...argvFiles] = process.argv;\n\nif (flowBin) {\n    run(flowBin, argvFiles).catch((err) => {\n        console.error(err);\n        process.exit(1);\n    });\n} else {\n    const flowBin = process.env['INPUT_FLOW-BIN'];\n    const filesRaw = process.env['INPUT_FILES'];\n    if (!flowBin) {\n        console.log('Must supply flow-bin argument');\n        process.exit(1);\n    } else if (!filesRaw) {\n        console.log('Must supply \"files\" argument');\n        process.exit(1);\n    } else {\n        run(flowBin, filesRaw.split(':::')).catch((err) => {\n            console.error(err); // flow-uncovered-line\n            process.exit(1);\n        });\n    }\n}\n"]}